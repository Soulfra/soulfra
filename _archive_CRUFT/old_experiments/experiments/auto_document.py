#!/usr/bin/env python3
"""
Auto Documentation Generator - Stop Manual Posting!

Automatically generates blog posts from test results, code changes, and system status.
Runs tests â†’ Captures results â†’ Writes markdown â†’ Posts to database.

Teaching the pattern:
1. Run tests (subprocess) â†’ Capture output
2. Parse results â†’ Extract insights
3. Generate markdown â†’ Structured post
4. Save to database â†’ Automated publishing

No more manual "we need more posts" - this does it automatically!

Use cases:
- Daily test reports
- Feature release documentation
- System status updates
- Learning journey posts
"""

import subprocess
import os
from datetime import datetime
import json
from database import get_db


def run_command_capture_output(command, timeout=60):
    """
    Run command and capture output

    Args:
        command: Command to run (list or string)
        timeout: Command timeout in seconds

    Returns:
        tuple: (return_code, stdout, stderr)

    Learning: subprocess.run() captures command output
    """
    try:
        result = subprocess.run(
            command,
            capture_output=True,
            text=True,
            timeout=timeout,
            shell=isinstance(command, str)
        )
        return (result.returncode, result.stdout, result.stderr)
    except subprocess.TimeoutExpired:
        return (None, "", f"Command timed out after {timeout}s")
    except Exception as e:
        return (None, "", str(e))


def run_tests_and_capture():
    """
    Run all test suites and capture results

    Returns:
        dict: Test results summary

    Learning: Aggregate multiple test outputs
    """
    results = {
        'timestamp': datetime.now().isoformat(),
        'tests': []
    }

    # Test suites to run
    test_files = [
        ('Database Tests', 'python3 test_database.py'),
        ('App Tests', 'python3 test_app.py'),
        ('Avatar Tests', 'python3 test_avatar_generator.py'),
        ('Pixel Utils Tests', 'python3 pixel_utils.py'),
        ('Soul Visualizer Tests', 'python3 soul_visualizer.py'),
        ('Soul QR Tests', 'python3 soul_qr.py'),
        ('Visual DIY Tests', 'python3 test_visual_diy.py'),
    ]

    for name, command in test_files:
        print(f"Running {name}...")
        code, stdout, stderr = run_command_capture_output(command)

        # Parse success/failure from output
        passed = code == 0 and ('passed' in stdout.lower() or 'âœ…' in stdout)

        results['tests'].append({
            'name': name,
            'command': command,
            'passed': passed,
            'return_code': code,
            'output_lines': len(stdout.split('\n')),
            'has_errors': bool(stderr)
        })

    return results


def generate_test_report_markdown(test_results):
    """
    Generate markdown blog post from test results

    Args:
        test_results: Dict from run_tests_and_capture()

    Returns:
        str: Markdown content

    Learning: Convert structured data â†’ readable markdown
    """
    timestamp = datetime.fromisoformat(test_results['timestamp'])
    date_str = timestamp.strftime('%Y-%m-%d %H:%M')

    # Count passed/failed
    passed = sum(1 for t in test_results['tests'] if t['passed'])
    total = len(test_results['tests'])

    # Build markdown
    md = f"""# Automated Test Report - {date_str}

**Test Suite Summary**: {passed}/{total} test suites passed

## Results

"""

    # Add each test result
    for test in test_results['tests']:
        status = 'âœ…' if test['passed'] else 'âŒ'
        md += f"### {status} {test['name']}\n\n"

        if test['passed']:
            md += f"- Status: Passed\n"
        else:
            md += f"- Status: Failed (return code: {test['return_code']})\n"

        md += f"- Output: {test['output_lines']} lines\n"

        if test['has_errors']:
            md += f"- Errors: Yes\n"

        md += "\n"

    # Add summary
    md += "## Summary\n\n"

    if passed == total:
        md += f"ðŸŽ‰ All {total} test suites passed! The system is healthy.\n\n"
    else:
        failed = total - passed
        md += f"âš ï¸ {failed} test suite(s) failed. Review errors above.\n\n"

    # Add metadata
    md += "---\n\n"
    md += "*This post was automatically generated by auto_document.py*\n"
    md += f"*Generated at: {date_str}*\n"

    return md


def generate_feature_release_post(feature_name, description, files_changed):
    """
    Generate markdown post for new feature release

    Args:
        feature_name: Name of feature
        description: Feature description
        files_changed: List of file paths changed

    Returns:
        str: Markdown content

    Learning: Document new features automatically
    """
    date_str = datetime.now().strftime('%Y-%m-%d')

    md = f"""# New Feature: {feature_name}

**Released**: {date_str}

## Overview

{description}

## Files Changed

"""

    for filepath in files_changed:
        md += f"- `{filepath}`\n"

    md += "\n## Testing\n\n"
    md += "All tests passing. Feature ready for use.\n\n"
    md += "---\n\n"
    md += "*Auto-documented feature release*\n"

    return md


def post_to_database(title, content, author_id=1, category='automated'):
    """
    Save post to database

    Args:
        title: Post title
        content: Post content (markdown)
        author_id: User ID of author (default 1)
        category: Post category

    Returns:
        int: Post ID

    Learning: Automated publishing to database
    """
    db = get_db()

    cursor = db.execute(
        'INSERT INTO posts (title, content, author_id, created_at) VALUES (?, ?, ?, ?)',
        (title, content, author_id, datetime.now().isoformat())
    )

    post_id = cursor.lastrowid
    db.commit()
    db.close()

    return post_id


def save_markdown_file(content, filename, output_dir='posts'):
    """
    Save markdown to file

    Args:
        content: Markdown content
        filename: Filename (without path)
        output_dir: Output directory

    Returns:
        str: Saved filepath

    Learning: Backup posts as files
    """
    os.makedirs(output_dir, exist_ok=True)
    filepath = os.path.join(output_dir, filename)

    with open(filepath, 'w', encoding='utf-8') as f:
        f.write(content)

    return filepath


def auto_document_tests(save_to_db=False):
    """
    Run tests and automatically document results

    Args:
        save_to_db: Whether to save post to database

    Returns:
        tuple: (markdown_content, filepath, post_id or None)

    Learning: End-to-end automated documentation
    """
    print("=" * 70)
    print("ðŸ“ Auto-Documenting Test Results")
    print("=" * 70)
    print()

    # Run tests
    print("ðŸ§ª Running test suites...\n")
    results = run_tests_and_capture()

    # Generate markdown
    print("\nðŸ“„ Generating markdown post...\n")
    markdown = generate_test_report_markdown(results)

    # Save to file
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    filename = f'test_report_{timestamp}.md'
    filepath = save_markdown_file(markdown, filename)

    print(f"âœ… Saved markdown: {filepath}")

    # Optionally save to database
    post_id = None
    if save_to_db:
        title = f"Test Report - {datetime.now().strftime('%Y-%m-%d %H:%M')}"
        post_id = post_to_database(title, markdown)
        print(f"âœ… Posted to database (ID: {post_id})")

    print("\n" + "=" * 70)
    print("ðŸ“ Auto-documentation complete!")
    print("=" * 70)

    return (markdown, filepath, post_id)


def auto_document_feature(feature_name, description, files_changed, save_to_db=False):
    """
    Automatically document new feature

    Args:
        feature_name: Feature name
        description: Feature description
        files_changed: List of changed files
        save_to_db: Save to database

    Returns:
        tuple: (markdown_content, filepath, post_id or None)

    Learning: Document features as they're built
    """
    print(f"ðŸ“ Auto-documenting feature: {feature_name}")

    # Generate markdown
    markdown = generate_feature_release_post(feature_name, description, files_changed)

    # Save to file
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    filename = f'feature_{feature_name.lower().replace(" ", "_")}_{timestamp}.md'
    filepath = save_markdown_file(markdown, filename)

    print(f"âœ… Saved: {filepath}")

    # Save to database
    post_id = None
    if save_to_db:
        title = f"New Feature: {feature_name}"
        post_id = post_to_database(title, markdown)
        print(f"âœ… Posted to database (ID: {post_id})")

    return (markdown, filepath, post_id)


def test_auto_document():
    """Test the auto documentation system"""
    print("ðŸ§ª Testing Auto Documentation\n")

    # Test 1: Generate test report (don't save to DB)
    print("1. Testing Test Report Generation:")
    md, filepath, post_id = auto_document_tests(save_to_db=False)

    print(f"\n   Generated {len(md)} characters of markdown")
    print(f"   Saved to: {filepath}")
    print(f"   Posted to DB: {post_id is not None}")
    print()

    # Test 2: Generate feature release post
    print("2. Testing Feature Release Documentation:")
    feature_md, feature_path, feature_id = auto_document_feature(
        "Auto Documentation System",
        "Automatically generates blog posts from test results and feature changes. No more manual posting!",
        ["auto_document.py", "test_auto_document.py"],
        save_to_db=False
    )

    print(f"   Generated {len(feature_md)} characters of markdown")
    print(f"   Saved to: {feature_path}")
    print()

    # Test 3: Markdown structure
    print("3. Testing Markdown Structure:")
    has_header = md.startswith('#')
    has_summary = 'Summary' in md
    has_metadata = 'automatically generated' in md.lower()

    print(f"   Has header: {has_header}")
    print(f"   Has summary: {has_summary}")
    print(f"   Has metadata: {has_metadata}")
    print()

    # Cleanup test files
    import shutil
    if os.path.exists('posts'):
        shutil.rmtree('posts')

    print("âœ… All auto-documentation tests passed!")


if __name__ == '__main__':
    import sys

    # Check for command line args
    if len(sys.argv) > 1:
        if sys.argv[1] == '--test':
            test_auto_document()
        elif sys.argv[1] == '--run':
            # Run and save to database
            auto_document_tests(save_to_db=True)
        else:
            print("Usage:")
            print("  python3 auto_document.py --test   # Test mode")
            print("  python3 auto_document.py --run    # Run and save to database")
    else:
        # Default: test mode
        test_auto_document()
