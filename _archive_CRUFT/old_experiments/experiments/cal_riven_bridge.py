#!/usr/bin/env python3
"""
Cal-Riven Bridge - AI Newsletter Integration

Bridges Soulfra Simple with Cal-Riven multi-LLM AI system:
1. Watches for new posts in Soulfra Simple database
2. Sends content to Cal-Riven for 3-brand AI analysis
3. Creates AI commentary posts back in Soulfra
4. Emails first subscriber (you) with AI perspectives

Usage:
    python cal_riven_bridge.py              # Run once
    python cal_riven_bridge.py --watch      # Watch mode (every 30 sec)
    python cal_riven_bridge.py --process-id <post_id>  # Process specific post
"""

import os
import sys
import time
import argparse
from datetime import datetime

# Add parent directory to path to import generate_article_debate
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

try:
    from python.generate_article_debate import generate_debate
except ImportError:
    print("‚ùå Error: Could not import generate_article_debate from parent directory")
    print("   Make sure you're running from soulfra-simple directory")
    print("   and that ../python/generate_article_debate.py exists")
    sys.exit(1)

# Local imports
import database as db
from emails import send_post_email
from db_helpers import (
    add_comment,
    create_reasoning_thread,
    add_reasoning_step,
    get_user_by_username
)


def log(message):
    """Log with timestamp"""
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    print(f"[{timestamp}] {message}")


def generate_slug_from_title(title):
    """Generate URL-safe slug from title"""
    import re
    # Remove special chars and convert to lowercase
    slug = title.lower()
    slug = re.sub(r'[^a-z0-9\s-]', '', slug)
    slug = re.sub(r'\s+', '-', slug)
    slug = slug[:50]  # Limit length
    return slug


def format_ai_analysis_as_markdown(original_post, analysis):
    """Format AI analysis results as markdown content"""

    perspectives = analysis.get('perspectives', {})
    analysis_data = analysis.get('analysis', {})

    # Extract data
    keywords = ', '.join(analysis_data.get('keywords', [])[:5])
    sentiment = analysis_data.get('sentiment', {}).get('sentiment', 'neutral')
    word_count = analysis_data.get('word_count', 0)

    # Build markdown
    md = f"""# ü§ñ AI Analysis: {original_post['title']}

_AI-generated multi-domain perspective analysis by Cal-Riven system_

---

## Original Post Summary

**Keywords:** {keywords}
**Sentiment:** {sentiment}
**Word Count:** {word_count}

---

## üîê Soulfra's Perspective (Security Focus)

{perspectives.get('soulfra', {}).get('take', 'Analysis unavailable')}

**Confidence:** {int(perspectives.get('soulfra', {}).get('confidence', 0) * 100)}%

---

## üïµÔ∏è DeathToData's Perspective (Privacy Advocacy)

{perspectives.get('deathtodata', {}).get('take', 'Analysis unavailable')}

**Confidence:** {int(perspectives.get('deathtodata', {}).get('confidence', 0) * 100)}%

---

## üíª CalRiven's Perspective (Technical Architecture)

{perspectives.get('calriven', {}).get('take', 'Analysis unavailable')}

**Confidence:** {int(perspectives.get('calriven', {}).get('confidence', 0) * 100)}%

---

## Arbiter Decision

{analysis.get('arbiter_decision', {}).get('reasoning', 'No arbiter decision available')}

**Winner:** {analysis.get('arbiter_decision', {}).get('winner', 'No clear winner')}

---

_Generated by Cal-Riven AI System ‚Ä¢ [View Original Post](/post/{original_post['slug']})_
"""

    return md


def process_post(post):
    """Process a single post with Cal-Riven AI"""

    log(f"üé≠ Processing: {post['title'][:60]}...")

    try:
        # Generate AI analysis using Cal-Riven system
        log("   ü§ñ Calling Cal-Riven AI...")
        analysis = generate_debate(
            url=f"internal-post-{post['id']}",
            article_content=post['content']
        )

        if not analysis or 'perspectives' not in analysis:
            log("   ‚ùå Failed to generate AI analysis")
            return False

        log("   ‚úÖ AI analysis complete")

        # Get Soulfra AI user to initiate reasoning thread
        soulfra_user = get_user_by_username('soulfra')
        if not soulfra_user:
            log("   ‚ùå Soulfra AI user not found")
            return False

        # Create reasoning thread
        log("   üßµ Creating reasoning thread...")
        thread_id = create_reasoning_thread(
            post_id=post['id'],
            initiator_user_id=soulfra_user['id'],
            topic=post['title']
        )

        # Add AI comments with reasoning steps
        perspectives = analysis.get('perspectives', {})
        step_number = 1

        for persona_name, persona_data in perspectives.items():
            # Get AI user
            ai_user = get_user_by_username(persona_name)
            if not ai_user:
                log(f"   ‚ö†Ô∏è  AI user not found: {persona_name}")
                continue

            # Format comment content
            take = persona_data.get('take', 'Analysis unavailable')
            confidence = persona_data.get('confidence', 0)

            comment_content = f"{take}\n\n**Confidence:** {int(confidence * 100)}%"

            # Add comment to post
            log(f"   üí¨ Adding comment from {persona_name}...")
            comment_id = add_comment(
                post_id=post['id'],
                user_id=ai_user['id'],
                content=comment_content
            )

            # Track reasoning step linked to comment
            add_reasoning_step(
                thread_id=thread_id,
                user_id=ai_user['id'],
                step_number=step_number,
                step_type='analysis',
                content=take,
                confidence=confidence,
                comment_id=comment_id
            )

            log(f"   ‚úÖ {persona_name} commented (confidence: {int(confidence * 100)}%)")
            step_number += 1

        # Add arbiter decision as a comment if available
        arbiter = analysis.get('arbiter_decision', {})
        if arbiter and arbiter.get('reasoning'):
            arbiter_content = f"## Arbiter Decision\n\n{arbiter['reasoning']}\n\n**Winner:** {arbiter.get('winner', 'No clear winner')}"

            # Add as comment from Soulfra
            arbiter_comment_id = add_comment(
                post_id=post['id'],
                user_id=soulfra_user['id'],
                content=arbiter_content
            )

            add_reasoning_step(
                thread_id=thread_id,
                user_id=soulfra_user['id'],
                step_number=step_number,
                step_type='synthesis',
                content=arbiter['reasoning'],
                confidence=1.0,
                comment_id=arbiter_comment_id
            )

            log("   ‚úÖ Arbiter decision added")

        # Mark original post as processed
        db.mark_post_ai_processed(post['id'])
        log(f"   ‚úÖ AI analysis complete - {step_number} reasoning steps created")

        log(f"   ‚úÖ Processing complete!")
        return True

    except Exception as e:
        log(f"   ‚ùå Error processing post: {e}")
        import traceback
        traceback.print_exc()
        return False


def run_once():
    """Process all unprocessed posts once"""
    log("=" * 70)
    log("üöÄ Cal-Riven Bridge Starting")
    log("=" * 70)

    # Get unprocessed posts
    posts = db.get_unprocessed_posts()

    if not posts:
        log("‚úÖ No new posts to process")
        return

    log(f"üì∞ Found {len(posts)} unprocessed posts")

    for post in posts:
        process_post(post)
        time.sleep(2)  # Rate limit

    log("=" * 70)
    log("‚úÖ Bridge run complete")
    log("=" * 70)


def watch_mode():
    """Continuously watch for new posts"""
    log("üëÄ Watch mode activated - checking every 30 seconds")
    log("Press Ctrl+C to stop\n")

    try:
        while True:
            run_once()
            log("\nüí§ Sleeping for 30 seconds...\n")
            time.sleep(30)
    except KeyboardInterrupt:
        log("\nüëã Stopping watch mode")


def process_specific_post(post_id):
    """Process a specific post by ID"""
    log(f"üéØ Processing specific post ID: {post_id}")

    post = db.get_post_by_slug(str(post_id))  # Try as slug first

    if not post:
        # Try as ID
        posts = db.get_posts()
        post = next((p for p in posts if p['id'] == int(post_id)), None)

    if not post:
        log(f"‚ùå Post not found: {post_id}")
        return False

    return process_post(post)


def main():
    parser = argparse.ArgumentParser(description='Cal-Riven AI Newsletter Bridge')
    parser.add_argument('--watch', action='store_true', help='Watch mode (continuous)')
    parser.add_argument('--process-id', type=str, help='Process specific post by ID or slug')

    args = parser.parse_args()

    if args.process_id:
        process_specific_post(args.process_id)
    elif args.watch:
        watch_mode()
    else:
        run_once()


if __name__ == '__main__':
    main()
