<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Record - CringeProof</title>
<meta name="description" content="Record voice memos with AI transcription and smart tagging">
<link rel="stylesheet" href="./css/soulfra.css">
<style>
body {
    background: linear-gradient(135deg, #000 0%, #1a1a2e 100%);
    color: white;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    margin: 0;
    padding: 0;
}

.record-container {
    max-width: 800px;
    margin: 2rem auto;
    padding: 2rem;
}

.auth-bar {
    background: rgba(255, 255, 255, 0.05);
    padding: 1rem;
    border-radius: 12px;
    margin-bottom: 2rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.auth-status {
    font-size: 0.9rem;
    color: rgba(255, 255, 255, 0.7);
}

.auth-btn {
    background: #ff006e;
    color: white;
    border: 2px solid #000;
    padding: 0.5rem 1rem;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 700;
    transition: all 0.2s;
}

.auth-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 0 #000;
}

.recorder-card {
    background: rgba(255, 255, 255, 0.05);
    backdrop-filter: blur(10px);
    border: 3px solid #ff006e;
    border-radius: 16px;
    padding: 2rem;
    margin-bottom: 2rem;
}

.recorder-header {
    text-align: center;
    margin-bottom: 2rem;
}

.recorder-header h1 {
    font-size: 2.5rem;
    font-weight: 900;
    margin-bottom: 0.5rem;
    background: linear-gradient(135deg, #ff006e 0%, #bdb2ff 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
}

.recorder-status {
    font-size: 1.1rem;
    font-weight: 700;
    color: #ffe5ec;
    margin-bottom: 2rem;
    text-align: center;
    text-transform: uppercase;
}

.record-btn {
    width: 100%;
    padding: 2rem;
    font-size: 1.5rem;
    font-weight: 900;
    color: white;
    background: #ff006e;
    border: 4px solid #000;
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.2s;
    box-shadow: 0 6px 0 #000;
    margin-bottom: 1.5rem;
}

.record-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 0 #000;
}

.record-btn:active {
    transform: translateY(2px);
    box-shadow: 0 3px 0 #000;
}

.record-btn.recording {
    background: #000;
    animation: pulse 1.5s infinite;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
}

.waveform {
    height: 80px;
    background: rgba(0, 0, 0, 0.3);
    border: 2px solid rgba(255, 255, 255, 0.2);
    border-radius: 8px;
    margin-bottom: 1.5rem;
    display: none;
    position: relative;
    overflow: hidden;
}

.waveform.active {
    display: block;
}

.waveform-bar {
    position: absolute;
    bottom: 0;
    width: 4px;
    background: #ff006e;
    transition: height 0.1s;
}

.editor-section {
    display: none;
    margin-top: 2rem;
}

.editor-section.active {
    display: block;
}

.transcription-box {
    width: 100%;
    min-height: 150px;
    padding: 1rem;
    font-size: 1rem;
    font-family: inherit;
    color: white;
    background: rgba(0, 0, 0, 0.3);
    border: 2px solid rgba(255, 255, 255, 0.2);
    border-radius: 8px;
    resize: vertical;
    margin-bottom: 1rem;
}

.transcription-box:focus {
    outline: none;
    border-color: #ff006e;
}

.ai-suggestions {
    background: rgba(189, 178, 255, 0.1);
    border: 2px solid #bdb2ff;
    border-radius: 8px;
    padding: 1rem;
    margin-bottom: 1rem;
}

.ai-suggestions h3 {
    font-size: 0.9rem;
    text-transform: uppercase;
    color: #bdb2ff;
    margin-bottom: 0.75rem;
}

.tag-list {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
}

.tag {
    background: rgba(255, 255, 255, 0.1);
    padding: 0.5rem 1rem;
    border-radius: 20px;
    font-size: 0.9rem;
    cursor: pointer;
    transition: all 0.2s;
    border: 2px solid transparent;
}

.tag:hover {
    background: rgba(255, 255, 255, 0.2);
}

.tag.selected {
    border-color: #ff006e;
    background: rgba(255, 0, 110, 0.2);
}

.action-buttons {
    display: flex;
    gap: 1rem;
    margin-top: 1.5rem;
}

.btn {
    flex: 1;
    padding: 1rem;
    font-size: 1rem;
    font-weight: 700;
    border: 3px solid #000;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s;
    box-shadow: 0 4px 0 #000;
}

.btn-primary {
    background: #00C49A;
    color: #000;
}

.btn-secondary {
    background: rgba(255, 255, 255, 0.1);
    color: white;
}

.btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 0 #000;
}

.btn:active {
    transform: translateY(1px);
    box-shadow: 0 2px 0 #000;
}

.recording-preview {
    margin-top: 1rem;
}

.recording-preview audio {
    width: 100%;
    margin-bottom: 1rem;
}

.cache-notice {
    background: rgba(255, 230, 109, 0.15);
    border: 2px solid #ffe66d;
    border-radius: 8px;
    padding: 1rem;
    text-align: center;
    font-size: 0.9rem;
    color: #ffe66d;
    margin-top: 1rem;
}
</style>
</head>
<body>

<div class="record-container">
    <!-- Auth Bar -->
    <div class="auth-bar">
        <div class="auth-status" id="authStatus">
            üë§ Anonymous Session
        </div>
        <button class="auth-btn" id="authBtn" onclick="toggleAuth()">
            Login / Sign Up
        </button>
    </div>

    <!-- Recorder Card -->
    <div class="recorder-card">
        <div class="recorder-header">
            <h1>üéôÔ∏è Record</h1>
            <div class="recorder-status" id="status">Ready to Record</div>
        </div>

        <div class="waveform" id="waveform"></div>

        <button class="record-btn" id="recordBtn" onclick="toggleRecording()">
            üé§ Start Recording
        </button>

        <!-- Editor Section (shown after recording) -->
        <div class="editor-section" id="editorSection">
            <div class="recording-preview">
                <audio id="audioPlayback" controls></audio>
            </div>

            <label style="font-size: 0.9rem; color: rgba(255, 255, 255, 0.7); margin-bottom: 0.5rem; display: block;">
                ‚úçÔ∏è Transcription (edit as needed)
            </label>
            <textarea
                class="transcription-box"
                id="transcription"
                placeholder="Transcription will appear here..."></textarea>

            <div class="ai-suggestions" id="aiSuggestions" style="display: none;">
                <h3>ü§ñ AI Detected Topics</h3>
                <div class="tag-list" id="tagList"></div>
            </div>

            <div class="action-buttons">
                <button class="btn btn-secondary" onclick="cancelRecording()">
                    üóëÔ∏è Discard
                </button>
                <button class="btn btn-secondary" onclick="savePrivate()">
                    üíæ Save Private
                </button>
                <button class="btn btn-primary" onclick="publishToWall()">
                    üì¢ Publish to Wall
                </button>
            </div>

            <div class="cache-notice" id="cacheNotice" style="display: none;">
                üíæ Saved to localStorage. Login to sync across devices.
            </div>
        </div>
    </div>
</div>

<script>
const API_BASE = window.location.origin;

// Session management
let currentUser = null;
let sessionId = localStorage.getItem('sessionId') || generateSessionId();
localStorage.setItem('sessionId', sessionId);

// Recording state
let mediaRecorder;
let audioChunks = [];
let isRecording = false;
let audioContext, analyser, dataArray, animationId;
let currentBlob = null;
let currentTranscription = null;

function generateSessionId() {
    return 'anon_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
}

// Auth functions
async function checkAuth() {
    const token = localStorage.getItem('authToken');
    if (!token) {
        updateAuthUI(null);
        return;
    }

    try {
        const response = await fetch(`${API_BASE}/api/auth/me`, {
            headers: {
                'Authorization': `Bearer ${token}`
            }
        });

        if (response.ok) {
            const user = await response.json();
            currentUser = user;
            updateAuthUI(user);
        } else {
            localStorage.removeItem('authToken');
            updateAuthUI(null);
        }
    } catch (error) {
        console.error('Auth check failed:', error);
        updateAuthUI(null);
    }
}

function updateAuthUI(user) {
    const statusEl = document.getElementById('authStatus');
    const btnEl = document.getElementById('authBtn');

    if (user) {
        statusEl.textContent = `üë§ ${user.username || user.display_name}`;
        btnEl.textContent = 'Logout';
        document.getElementById('cacheNotice').style.display = 'none';
    } else {
        statusEl.textContent = `üë§ Anonymous Session (${sessionId.substr(0, 12)}...)`;
        btnEl.textContent = 'Login / Sign Up';
    }
}

function toggleAuth() {
    if (currentUser) {
        logout();
    } else {
        window.location.href = '/login.html';
    }
}

function logout() {
    localStorage.removeItem('authToken');
    currentUser = null;
    updateAuthUI(null);
}

// Recording functions
async function toggleRecording() {
    if (isRecording) {
        stopRecording();
    } else {
        await startRecording();
    }
}

async function startRecording() {
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

        mediaRecorder = new MediaRecorder(stream);
        audioChunks = [];

        // Setup audio visualization
        audioContext = new AudioContext();
        analyser = audioContext.createAnalyser();
        const source = audioContext.createMediaStreamSource(stream);
        source.connect(analyser);
        analyser.fftSize = 256;
        const bufferLength = analyser.frequencyBinCount;
        dataArray = new Uint8Array(bufferLength);

        // Show waveform
        document.getElementById('waveform').classList.add('active');
        visualize();

        mediaRecorder.ondataavailable = (event) => {
            audioChunks.push(event.data);
        };

        mediaRecorder.onstop = async () => {
            currentBlob = new Blob(audioChunks, { type: 'audio/webm' });

            // Show playback
            const audioUrl = URL.createObjectURL(currentBlob);
            document.getElementById('audioPlayback').src = audioUrl;

            // Upload and transcribe
            await uploadAndTranscribe(currentBlob);

            // Stop visualization
            cancelAnimationFrame(animationId);
            document.getElementById('waveform').classList.remove('active');

            // Close audio context
            if (audioContext) {
                audioContext.close();
            }
        };

        mediaRecorder.start();
        isRecording = true;

        document.getElementById('status').textContent = 'üî¥ Recording...';
        document.getElementById('recordBtn').textContent = '‚èπÔ∏è Stop Recording';
        document.getElementById('recordBtn').classList.add('recording');

    } catch (error) {
        alert(`Microphone error: ${error.message}`);
        console.error('Recording error:', error);
    }
}

function stopRecording() {
    if (mediaRecorder && isRecording) {
        mediaRecorder.stop();
        isRecording = false;

        document.getElementById('status').textContent = '‚è≥ Transcribing...';
        document.getElementById('recordBtn').textContent = 'üé§ Start Recording';
        document.getElementById('recordBtn').classList.remove('recording');

        // Stop all tracks
        mediaRecorder.stream.getTracks().forEach(track => track.stop());
    }
}

async function uploadAndTranscribe(audioBlob) {
    const formData = new FormData();
    formData.append('audio', audioBlob, 'recording.webm');
    formData.append('session_id', sessionId);

    try {
        const response = await fetch(`${API_BASE}/api/simple-voice/save`, {
            method: 'POST',
            body: formData,
            headers: currentUser ? {
                'Authorization': `Bearer ${localStorage.getItem('authToken')}`
            } : {}
        });

        if (response.ok) {
            const result = await response.json();
            currentTranscription = result.transcription || '';

            document.getElementById('transcription').value = currentTranscription;
            document.getElementById('status').textContent = '‚úÖ Ready to Edit';
            document.getElementById('editorSection').classList.add('active');

            // Extract AI suggestions
            if (currentTranscription) {
                extractTopics(currentTranscription);
            }

            // Show cache notice if anonymous
            if (!currentUser) {
                document.getElementById('cacheNotice').style.display = 'block';
            }
        } else {
            alert('Upload failed. Please try again.');
            document.getElementById('status').textContent = 'Ready to Record';
        }
    } catch (error) {
        alert(`Upload error: ${error.message}`);
        document.getElementById('status').textContent = 'Ready to Record';
        console.error('Upload error:', error);
    }
}

function extractTopics(text) {
    // Simple keyword extraction (can be enhanced with AI)
    const domains = ['cringeproof', 'soulfra', 'calriven', 'deathtodata'];
    const suggestedTags = [];

    text = text.toLowerCase();

    domains.forEach(domain => {
        if (text.includes(domain) || text.includes(domain.replace('cringe', 'cringe ').replace('soul', 'soul ').replace('cal', 'cal ').replace('death', 'death '))) {
            suggestedTags.push(domain);
        }
    });

    // Generic topic detection
    const topics = {
        'ai': ['ai', 'artificial intelligence', 'machine learning', 'llm'],
        'privacy': ['privacy', 'surveillance', 'tracking', 'data'],
        'social': ['social', 'community', 'friends', 'people'],
        'tech': ['tech', 'technology', 'code', 'developer']
    };

    Object.keys(topics).forEach(topic => {
        if (topics[topic].some(keyword => text.includes(keyword))) {
            suggestedTags.push(topic);
        }
    });

    if (suggestedTags.length > 0) {
        showSuggestions(suggestedTags);
    }
}

function showSuggestions(tags) {
    const suggestionsEl = document.getElementById('aiSuggestions');
    const tagListEl = document.getElementById('tagList');

    tagListEl.innerHTML = tags.map(tag =>
        `<div class="tag" onclick="toggleTag(this)">${tag}</div>`
    ).join('');

    suggestionsEl.style.display = 'block';
}

function toggleTag(tagEl) {
    tagEl.classList.toggle('selected');
}

function visualize() {
    const waveformEl = document.getElementById('waveform');
    const width = waveformEl.offsetWidth;
    const barCount = 50;
    const barWidth = width / barCount;

    // Clear existing bars
    waveformEl.innerHTML = '';

    // Create bars
    const bars = [];
    for (let i = 0; i < barCount; i++) {
        const bar = document.createElement('div');
        bar.className = 'waveform-bar';
        bar.style.left = `${i * barWidth}px`;
        bar.style.width = `${barWidth - 2}px`;
        waveformEl.appendChild(bar);
        bars.push(bar);
    }

    function draw() {
        animationId = requestAnimationFrame(draw);

        analyser.getByteFrequencyData(dataArray);

        for (let i = 0; i < barCount; i++) {
            const dataIndex = Math.floor(i * dataArray.length / barCount);
            const height = (dataArray[dataIndex] / 255) * 100;
            bars[i].style.height = `${height}%`;
        }
    }

    draw();
}

function cancelRecording() {
    document.getElementById('editorSection').classList.remove('active');
    document.getElementById('status').textContent = 'Ready to Record';
    currentBlob = null;
    currentTranscription = null;
}

async function savePrivate() {
    alert('‚úÖ Recording saved privately!');
    resetRecorder();
}

async function publishToWall() {
    const transcription = document.getElementById('transcription').value;
    const selectedTags = Array.from(document.querySelectorAll('.tag.selected'))
        .map(el => el.textContent);

    // TODO: Publish to wall endpoint
    alert(`üì¢ Publishing to Wall!\nTags: ${selectedTags.join(', ')}`);

    resetRecorder();
}

function resetRecorder() {
    document.getElementById('editorSection').classList.remove('active');
    document.getElementById('status').textContent = 'Ready to Record';
    document.getElementById('transcription').value = '';
    document.getElementById('aiSuggestions').style.display = 'none';
    currentBlob = null;
    currentTranscription = null;
}

// Initialize
checkAuth();
</script>

</body>
</html>
