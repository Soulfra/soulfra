<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Record Voice - CringeProof</title>
<meta name="description" content="Record voice memos - works offline, no backend needed">

<!-- PWA Support -->
<link rel="manifest" href="/manifest.json">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="CringeProof">
<link rel="apple-touch-icon" href="/static/images/icon-192.png">
<meta name="theme-color" content="#ff006e">

<link rel="stylesheet" href="./css/soulfra.css">
<style>
.connection-badge {
    font-family: -apple-system, BlinkMacSystemFont, sans-serif;
    box-shadow: 4px 4px 0 #000;
}

.connection-badge.online {
    background: #00C49A;
    color: #000;
}

.connection-badge.offline {
    background: #ff006e;
    color: #fff;
}

.connection-badge.checking {
    background: #bdb2ff;
    color: #000;
}

.recorder-container {
    max-width: 600px;
    margin: 2rem auto;
    text-align: center;
    padding: 2rem;
}

.record-btn {
    background: #ff006e;
    color: white;
    border: 4px solid #000;
    padding: 3rem;
    font-size: 3rem;
    font-weight: 900;
    cursor: pointer;
    box-shadow: 8px 8px 0 #000;
    transition: all 0.1s;
    border-radius: 50%;
    width: 200px;
    height: 200px;
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 2rem auto;
}

.record-btn:active {
    transform: scale(0.95);
    box-shadow: 4px 4px 0 #000;
}

.record-btn.recording {
    background: #000;
    animation: pulse 1s infinite;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.6; }
}

.recordings-list {
    margin-top: 3rem;
    text-align: left;
}

.recording-item {
    background: #fff;
    border: 4px solid #000;
    padding: 1.5rem;
    margin-bottom: 1rem;
    box-shadow: 6px 6px 0 #bdb2ff;
}

.recording-item audio {
    width: 100%;
    margin: 1rem 0;
}

.delete-btn {
    background: #ff006e;
    color: white;
    border: 3px solid #000;
    padding: 0.5rem 1rem;
    cursor: pointer;
    font-weight: 900;
}

.status {
    font-size: 1.5rem;
    font-weight: 900;
    margin: 1rem 0;
    min-height: 3rem;
}

.info-box {
    background: #ffe5ec;
    border: 3px solid #000;
    padding: 1rem;
    margin: 2rem 0;
    text-align: left;
}
</style>
</head>
<body>
<nav class="soulfra-nav">
    <div class="soulfra-nav-container">
        <a href="/" class="soulfra-logo">üö´ CringeProof</a>
        <div class="soulfra-links">
            <a href="/ideas/">üí° Ideas</a>
            <a href="/">üé§ Archive</a>
            <a href="/record-simple.html" class="active">üéôÔ∏è Record</a>
            <a href="/login.html">üîê Login</a>
        </div>
    </div>
</nav>

<div class="container">
    <header style="text-align: center; margin: 2rem 0;">
        <h1>üéôÔ∏è Record Voice Memo</h1>
        <p class="subtitle">Works offline - saves to your device</p>
    </header>

    <div class="recorder-container">
        <div class="info-box">
            ‚úÖ <strong>No backend needed</strong> - recordings save to your browser<br>
            ‚úÖ <strong>Works offline</strong> - record anytime, anywhere<br>
            ‚úÖ <strong>Private</strong> - stays on your device<br>
            üì§ <strong>Optional sync</strong> - visit <a href="/sync.html" style="color: #ff006e; font-weight: 900;">/sync.html</a> for transcription
        </div>

        <div class="status" id="status">Tap to record</div>

        <button class="record-btn" id="recordBtn" onclick="toggleRecording()">
            üé§
        </button>

        <div id="shareLink" style="display: none; margin: 2rem auto; max-width: 500px; padding: 1.5rem; background: linear-gradient(135deg, #ff006e 0%, #ffc6ff 100%); border: 4px solid #000; box-shadow: 8px 8px 0 #000;">
            <h3 style="margin: 0 0 1rem 0; font-size: 1.5rem; color: #000;">üîó INSTANT SHARE LINK</h3>
            <a id="shareUrl" href="#" target="_blank" style="display: block; background: #fff; padding: 1rem; border: 3px solid #000; color: #ff006e; font-weight: 900; text-decoration: none; word-break: break-all; margin-bottom: 1rem;"></a>
            <p id="expiryInfo" style="margin: 0; color: #000; font-weight: 700;"></p>
            <button onclick="navigator.clipboard.writeText(document.getElementById('shareUrl').textContent); this.textContent='‚úÖ COPIED!'" style="background: #000; color: #fff; border: 3px solid #fff; padding: 0.75rem 1.5rem; font-weight: 900; cursor: pointer; width: 100%; margin-top: 1rem;">üìã COPY LINK</button>
            <p style="margin: 1rem 0 0 0; font-size: 0.875rem; color: #000;">üí° Want to keep your ideas forever? <a href="/signup.html" style="color: #000; text-decoration: underline;">Sign up for free</a></p>
        </div>

        <div class="recordings-list" id="recordingsList">
            <h2>Your Recordings (<span id="recordingCount">0</span>)</h2>
            <div id="recordings"></div>
        </div>
    </div>
</div>

<script src="./config.js"></script>
<script src="./queue-manager.js"></script>
<script src="./connection-monitor.js"></script>
<script>
// Register service worker
if ('serviceWorker' in navigator) {
  window.addEventListener('load', async () => {
    try {
      const registration = await navigator.serviceWorker.register('/sw.js');
      console.log('Service Worker registered:', registration.scope);

      // Listen for updates
      registration.addEventListener('updatefound', () => {
        const newWorker = registration.installing;
        console.log('Service Worker update found');

        newWorker.addEventListener('statechange', () => {
          if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
            console.log('New Service Worker available - refresh to update');
          }
        });
      });
    } catch (error) {
      console.error('Service Worker registration failed:', error);
    }
  });
}
</script>
<script>
// Configuration
const API_URL = window.CRINGEPROOF_CONFIG?.API_BACKEND_URL || 'https://localhost:5001';

// IndexedDB setup
let db;
const DB_NAME = 'CringeProofVoice';
const STORE_NAME = 'recordings';

// Initialize IndexedDB
async function initDB() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, 1);

        request.onerror = () => reject(request.error);
        request.onsuccess = () => {
            db = request.result;
            resolve(db);
        };

        request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(STORE_NAME)) {
                const objectStore = db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
                objectStore.createIndex('timestamp', 'timestamp', { unique: false });
            }
        };
    });
}

// Recording state
let mediaRecorder;
let audioChunks = [];
let isRecording = false;

async function toggleRecording() {
    if (isRecording) {
        stopRecording();
    } else {
        await startRecording();
    }
}

// iOS detection and audio format helper
function getMediaRecorderOptions() {
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);

    if (isIOS) {
        return { mimeType: 'audio/mp4', isIOS: true };
    } else if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
        return { mimeType: 'audio/webm;codecs=opus', isIOS: false };
    } else {
        return { mimeType: 'audio/webm', isIOS: false };
    }
}

async function startRecording() {
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

        const recorderConfig = getMediaRecorderOptions();
        mediaRecorder = new MediaRecorder(stream, { mimeType: recorderConfig.mimeType });
        audioChunks = [];

        mediaRecorder.ondataavailable = (event) => {
            audioChunks.push(event.data);
        };

        mediaRecorder.onstop = async () => {
            const audioBlob = new Blob(audioChunks, { type: recorderConfig.mimeType });
            await saveRecording(audioBlob);
            stream.getTracks().forEach(track => track.stop());
        };

        mediaRecorder.start();
        isRecording = true;

        document.getElementById('status').textContent = 'üî¥ Recording...';
        document.getElementById('recordBtn').classList.add('recording');
        document.getElementById('recordBtn').textContent = '‚èπÔ∏è';

    } catch (error) {
        document.getElementById('status').textContent = '‚ùå Microphone access denied';
        console.error('Recording error:', error);
    }
}

function stopRecording() {
    if (mediaRecorder && isRecording) {
        mediaRecorder.stop();
        isRecording = false;

        document.getElementById('status').textContent = '‚úÖ Saved!';
        document.getElementById('recordBtn').classList.remove('recording');
        document.getElementById('recordBtn').textContent = 'üé§';

        setTimeout(() => {
            document.getElementById('status').textContent = 'Tap to record';
        }, 2000);
    }
}

async function saveRecording(audioBlob) {
    const recording = {
        blob: audioBlob,
        timestamp: new Date().toISOString(),
        duration: 0,
        size: audioBlob.size,
        synced: false,
        transcription: null
    };

    // Save to IndexedDB first (offline backup)
    const transaction = db.transaction([STORE_NAME], 'readwrite');
    const store = transaction.objectStore(STORE_NAME);
    const addRequest = store.add(recording);

    addRequest.onsuccess = async () => {
        const recordingId = addRequest.result;

        // Try to upload to backend automatically
        try {
            document.getElementById('status').textContent = '‚òÅÔ∏è Uploading to server...';

            const formData = new FormData();
            formData.append('audio', audioBlob, 'recording.webm');

            const response = await fetch(`${API_URL}/api/simple-voice/save`, {
                method: 'POST',
                body: formData,
                credentials: 'include' // Send cookies for session
            });

            if (response.ok) {
                const result = await response.json();

                // Update recording with transcription if available
                if (result.transcription) {
                    recording.transcription = result.transcription;
                    recording.synced = true;

                    const updateTx = db.transaction([STORE_NAME], 'readwrite');
                    const updateStore = updateTx.objectStore(STORE_NAME);
                    await updateStore.put({...recording, id: recordingId});
                }

                let statusMsg = '‚úÖ Saved & synced!';
                if (result.username) {
                    statusMsg += ` (${result.username})`;
                }
                if (result.transcription) {
                    statusMsg += ' üìù';
                }

                document.getElementById('status').textContent = statusMsg;

                // INSTANT SHARING - Show shareable link
                if (result.public_url) {
                    const shareDiv = document.getElementById('shareLink');
                    const shareUrl = document.getElementById('shareUrl');
                    const expiryInfo = document.getElementById('expiryInfo');

                    shareUrl.href = result.public_url;
                    shareUrl.textContent = result.public_url;

                    if (result.expires_at) {
                        const expiryDate = new Date(result.expires_at);
                        const tierEmoji = result.tier === 'anonymous' ? '‚è∞' : 'üéÅ';
                        expiryInfo.textContent = `${tierEmoji} Expires: ${expiryDate.toLocaleString()}`;
                    }

                    shareDiv.style.display = 'block';
                }
            } else {
                document.getElementById('status').textContent = 'üíæ Saved offline (backend unavailable)';
            }
        } catch (error) {
            console.error('Upload failed:', error);
            document.getElementById('status').textContent = 'üíæ Saved offline (no connection)';
        }

        setTimeout(() => {
            document.getElementById('status').textContent = 'Tap to record';
        }, 3000);

        await loadRecordings();
    };
}

// Convert Blob to data URL (fixes Safari playback issue)
async function blobToDataURL(blob) {
    return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.readAsDataURL(blob);
    });
}

async function loadRecordings() {
    const transaction = db.transaction([STORE_NAME], 'readonly');
    const store = transaction.objectStore(STORE_NAME);
    const request = store.getAll();

    request.onsuccess = async () => {
        const recordings = request.result;
        await displayRecordings(recordings.reverse()); // Newest first
        document.getElementById('recordingCount').textContent = recordings.length;
    };
}

async function displayRecordings(recordings) {
    const container = document.getElementById('recordings');

    if (recordings.length === 0) {
        container.innerHTML = '<p style="text-align: center; opacity: 0.6;">No recordings yet</p>';
        return;
    }

    // Detect iOS for file extension
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
    const fileExt = isIOS ? 'm4a' : 'webm';
    const mimeType = isIOS ? 'audio/mp4' : 'audio/webm';

    const items = await Promise.all(recordings.map(async (recording, index) => {
        // Convert Blob to data URL (Safari can play these)
        const dataURL = await blobToDataURL(recording.blob);
        const date = new Date(recording.timestamp);
        const size = (recording.size / 1024).toFixed(1);

        return `
            <div class="recording-item">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                    <strong>Recording #${recordings.length - index}</strong>
                    <button class="delete-btn" onclick="deleteRecording(${index})">üóëÔ∏è Delete</button>
                </div>
                <div style="font-size: 0.9rem; opacity: 0.7; margin-bottom: 0.5rem;">
                    ${date.toLocaleString()} ‚Ä¢ ${size} KB
                    ${recording.transcription ? '<br>üìù ' + recording.transcription.substring(0, 80) + '...' : ''}
                </div>
                <audio controls src="${dataURL}" type="${mimeType}"></audio>
                <div style="margin-top: 0.5rem;">
                    <a href="${dataURL}" download="recording-${recordings.length - index}.${fileExt}"
                       style="font-size: 0.9rem; color: #ff006e;">
                        ‚¨áÔ∏è Download (.${fileExt})
                    </a>
                </div>
            </div>
        `;
    }));

    container.innerHTML = items.join('');
}

async function deleteRecording(id) {
    if (!confirm('Delete this recording?')) return;

    const transaction = db.transaction([STORE_NAME], 'readwrite');
    const store = transaction.objectStore(STORE_NAME);

    await store.delete(id);
    await loadRecordings();
}

// Initialize on page load
window.addEventListener('DOMContentLoaded', async () => {
    try {
        await initDB();
        await loadRecordings();
    } catch (error) {
        console.error('DB initialization error:', error);
        document.getElementById('status').textContent = '‚ùå Storage not available';
    }
});
</script>

<footer>
    <div style="background: #ff006e; border: 4px solid #000; padding: 2rem; margin: 2rem 0;">
        <h3 style="margin-bottom: 1rem;">üì± Works Best On Your Phone</h3>
        <p style="margin-bottom: 1rem;">
            Open <strong>cringeproof.com/record-simple.html</strong> on your phone to record voice memos anytime.
        </p>
        <p style="font-size: 0.9rem; opacity: 0.9;">
            ‚úÖ No internet required (works offline)<br>
            ‚úÖ Recordings saved locally (private)<br>
            ‚úÖ Download or share anytime
        </p>
    </div>

    <p style="text-align: center; opacity: 0.7;">
        <a href="/">Home</a> |
        <a href="/ideas/">Ideas</a> |
        <a href="https://github.com/Soulfra/voice-archive">GitHub</a>
    </p>
</footer>
</body>
</html>
